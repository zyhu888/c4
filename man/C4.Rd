% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/C4.R
\name{C4}
\alias{C4}
\title{C4: Covariate Connectivity Combined Clustering}
\usage{
C4(
  adj_matrix,
  sim_matrix,
  K = NULL,
  alpha_seq = seq(0, 1, by = 0.1),
  itermax = 10,
  startn = 10
)
}
\arguments{
\item{adj_matrix}{Adjacency matrix of the network (symmetric, non-negative, with zero diagonal).}

\item{sim_matrix}{Similarity matrix derived from covariates (symmetric, non-negative, with zero diagonal).}

\item{K}{Number of clusters, or a range of integers. If a range is given,
the eigengap heuristic is used to select the best \code{K}. Default is \code{2:(n-1)}.}

\item{alpha_seq}{A numeric vector of candidate alpha values. Default is \code{seq(0, 1, by = 0.1)}.}

\item{itermax}{Maximum number of iterations for k-means. Default is 10.}

\item{startn}{Number of random starts for k-means. Default is 10.}
}
\value{
A list containing:
\item{alpha}{The selected alpha value.}
\item{K}{The selected number of clusters.}
\item{cluster}{Cluster membership assignments for each node.}
}
\description{
Perform C4 clustering, an adaptive spectral clustering method that integrates
network connectivity with node covariates for unknown number of communities.
The algorithm searches over a sequence of tuning parameters (\eqn{\alpha}) to
balance adjacency and covariate similarity, and selects the best result based
on silhouette score.
}
\details{
The method forms a convex combination of adjacency and covariate similarity matrices:
\deqn{(1-\alpha)W + \alpha S,}
where \eqn{W} is the adjacency matrix and \eqn{S} is the covariate similarity.
For each \eqn{\alpha}, the normalized Laplacian is computed, eigen-decomposition
is performed, and k-means is applied on the spectral embedding. The solution
with the highest silhouette score is returned.
}
\examples{
library(MASS)
set.seed(123)

# Generate covariates (200 nodes, 4 communities, 3 features per node)
# Each community has a different mean vector in 3D space
n <- 200; k <- 4; d <- 10; se <- 3
means <- matrix(c(
  d / sqrt(8),  d / sqrt(8),  d / sqrt(8),
  -d / sqrt(8), -d / sqrt(8),  d / sqrt(8),
  -d / sqrt(8),  d / sqrt(8), -d / sqrt(8),
  d / sqrt(8), -d / sqrt(8), -d / sqrt(8)
), nrow = 4, byrow = TRUE)
cov_matrix <- diag(se^2, 3)
community_sizes <- rep(n / k, k)

# Simulate multivariate normal features for each community
X <- do.call(rbind, lapply(1:k, function(c) {
  mvrnorm(community_sizes[c], means[c, ], cov_matrix)
}))

# Compute similarity matrix from covariates (Euclidean â†’ 1/distance)
D <- as.matrix(dist(X))
S <- 1 / D
diag(S) <- 0

# Generate adjacency matrix from a weighted SBM
W <- gen_weighted_sbm(
  node_num = 200,
  cluster_size = rep(50, 4),
  win_cluster_den = 0.3,
  win_cluster_dist = "runif",
  win_cluster_par = list(min = 1, max = 2),
  btw_cluster_den = 0.2,
  btw_cluster_dist = "runif",
  btw_cluster_par = list(min = 1, max = 2)
)$adjacency_matrix

# Run C4 clustering
result_C4 <- C4(W, S, alpha_seq = seq(0, 1, by = 0.1))
result_C4

}
\references{
Work in progress (manuscript in preparation).#'
}
